Концепция третьего решения:
arr[] = 2135467 #массив чисел
k     = 2       #переменная-условие
count = 0       #счетчик побед подряд

Возьмем за максимальное значение первый элемент массива:
max = arr[0];

Далее начнем цикл for, при условии (переменная-индекс i превышает размер массива или count равна k) цикл завершается:
for (int i = 1; i < arr.Length && count != k; i++) {}

Если max меньше arr[i], то max присваивается arr[i], count присваивается 1 и выполняется оператор перехода continue:
if (max < arr[i])
{
    max = arr[i];
    count = 1;
    continue;
}

Если max больше или равна arr[i], то инкреминтируем count:
count++;

Линейное представление:
int[] arr = {2,1,3,5,4,6,7}
int k     = 2
int count = 0
int max   = arr[0] # max = 2

for ;(line: 9)

#2135467
2 > 1       count++ -> 1
235467_1
2 < 3       count=1
35467|1_2
3 < 5       count=1
5467|12_3
5 > 4       count++ -> 2 -> 2 == k
-------------------------
Ответ: 5

if k = 3:

#2135467
2 > 1       count++ -> 1
235467_1
2 < 3       count=1
35467|1_2
3 < 5       count=1
5457|12_3
5 > 4       count++ -> 2
567|123_4
5 < 6       count=1
67|1234_5
6 < 7       count=1
7|12345_7

после этой итерации цикл завершиться, так как переменная-индекс i = arr.Length
может показаться что выход из цикла не верен, но если итерации продолжаться:
7 > 1       count++ -> 2
7|23456_1
7 > 2       count++ -> 3 -> count == k

семерка всегда будет победителем

return max;



